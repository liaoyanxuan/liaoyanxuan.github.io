<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Violet</title>
   <link href="http://liaoyanxuan.github.io/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://liaoyanxuan.github.io" rel="alternate" type="text/html" />
   <updated>2014-11-01T13:32:33+08:00</updated>
   <id>http://liaoyanxuan.github.io</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>在cocos2dx 3.x 中实现带颜色滤镜的Sprite</title>
     <link href="http://liaoyanxuan.github.io/2014/10/28/%E5%9C%A8cocos2dx-3.x-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%B8%A6%E9%A2%9C%E8%89%B2%E6%BB%A4%E9%95%9C%E7%9A%84Sprite.html"/>
     <updated>2014-10-28T00:00:00+08:00</updated>
     <id>http://liaoyanxuan.github.io/2014/10/28/在cocos2dx-3.x-中实现带颜色滤镜的Sprite</id>
     <content type="html">&lt;p&gt;&lt;strong&gt;一.目的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;cocos2dx做项目时经常会碰到要对图片进行变色的需求，最常用的就是变灰了，就要让按钮变灰来表示当前的状态是不可点的。
但是cocos2dx的Sprite中是没有这个变灰支持的。那么，就要我们自己动手来扩展实现一个。我们让这个带变色功能的Sprite叫做FilterSprite。这个FilterSprite扩展了Sprite的功能：可以方便地变换颜色。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二.原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对图片进行颜色变换，就是对图片上的每个像素进行变换。要实现这个，要新创建一个fragmentShader，这个fragmentShader
比sprite的那个fragmentShader多了一个颜色变换矩阵。shader会让图片上每个像素与颜色变换矩阵进行相乘，输出新的像素值。&lt;/p&gt;

&lt;p&gt;这个shader是这样的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;    &lt;span class=&quot;cp&quot;&gt;#ifdef GL_ES &lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;precision&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mediump&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endif&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uniform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sampler2D&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u_texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;varying&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v_texCoord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;varying&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v_fragmentColor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;uniform&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mat4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fiterMat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
       &lt;span class=&quot;n&quot;&gt;vec4&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v_fragmentColor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;texture2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u_texture&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v_texCoord&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
       &lt;span class=&quot;n&quot;&gt;gl_FragColor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fiterMat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从shader上我们看到，“filterMat” 就是所谓的颜色变换矩阵，仅仅在原来像素输出前用它处理了一下：与待输出像素相乘。
这个shader是opengl层级的，要应用到coco2dx引擎中，我们要着手实现cocos2dx的FilterSprite类了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三.实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实现这个FilterSprite注意几个要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;引擎中一个shader对应一个GLProgram，所以这个带颜色滤镜的shader（称为filterShader）对应一个GLProgram（称为filterProgram）对象，在实际使用时，是用对GLProgram进行了封装的GLProgramState（称为filterProgramState）对象，FilterSprite对象的_glProgramState要设置成filterProgramState对象，在源码中FilterSprite的initWithTexture进行这个filterShader和filterProgram的关联。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在渲染时要将滤镜传递给shader程序，在源码中就是在onDraw回调时调用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;glProgramState-&amp;gt;setUniformMat4( &amp;quot;fiterMat&amp;quot;,m_uSpriteFilter)。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;四.使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用起来非常简单，只需要设置一个颜色矩阵，例如，如果要变灰就设置一个灰度矩阵，如果要恢复原貌就设置一个单位矩阵。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Sprite *_sprite1;
_sprite1 = FilterSprite::create(&amp;quot;Images/background3.png&amp;quot;);

GLfloat  filterMat[16]= {
        0.3f,  0.3f,  0.3f,  0.0f,
        0.59f, 0.59f, 0.59f, 0.59f,
        0.11f, 0.11f, 0.11f, 0.0f,
        0.0f,  0.0f,  0.0f,  1.0f,
};

dynamic_cast&amp;lt;FilterSprite*&amp;gt;(_sprite1)-&amp;gt;setFilterMat(filterMat);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五.源码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;FilterSprite.h:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/****************************************************************************

 FilterSpirte.h

 Created by LiaoYanXuan  on 14-10-21.
 ****************************************************************************/

#ifndef __FilterSpirte_h
#define __FilterSpirte_h

#include &amp;quot;cocos2d.h&amp;quot;

USING_NS_CC;


class FilterSprite : public Sprite{

public:

    FilterSprite();
    virtual ~FilterSprite();

    static FilterSprite* create();
    static FilterSprite* create(const std::string&amp;amp; filename);
    static FilterSprite* create(const std::string&amp;amp; filename, const Rect&amp;amp; rect);


    static FilterSprite* createWithTexture(Texture2D *pTexture);
    static FilterSprite* createWithTexture(Texture2D *pTexture, const Rect&amp;amp; rect, bool rotated=false);
    static FilterSprite* createWithSpriteFrame(SpriteFrame *pSpriteFrame);
    static FilterSprite* createWithSpriteFrameName(const std::string&amp;amp; spriteFrameName);

    bool initWithTexture(Texture2D* pTexture, const Rect&amp;amp; tRect);
    virtual void draw(Renderer *renderer, const Mat4 &amp;amp;transform, uint32_t flags) override;
    void onDraw(const Mat4 &amp;amp;transform, uint32_t flags);
    void setFilterMat(cocos2d::Mat4 matrixArray);
    //to-do 提供一个设置滤镜的方法
protected:
    CustomCommand _customCommand;
private:
    cocos2d::Mat4   m_uSpriteFilter;
};

#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FilterSprite.cpp:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;/****************************************************************************
 FilterSpirte.h

 Created by LiaoYanXuan  on 14-10-21.
 ****************************************************************************/
#include &amp;quot;FilterSprite.h&amp;quot;

FilterSprite::FilterSprite(void)
{
    m_uSpriteFilter=Mat4::IDENTITY;
}

FilterSprite::~FilterSprite()
{

}

FilterSprite* FilterSprite::create()
{
    FilterSprite *sprite = new (std::nothrow) FilterSprite();
    if (sprite &amp;amp;&amp;amp; sprite-&amp;gt;init())
    {
        sprite-&amp;gt;autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}

FilterSprite* FilterSprite::create(const std::string&amp;amp; filename)
{
    FilterSprite *sprite = new (std::nothrow) FilterSprite();
    if (sprite &amp;amp;&amp;amp; sprite-&amp;gt;initWithFile(filename))
    {
        sprite-&amp;gt;autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}

FilterSprite* FilterSprite::create(const std::string&amp;amp; filename, const Rect&amp;amp; rect)
{
    FilterSprite *sprite = new (std::nothrow) FilterSprite();
    if (sprite &amp;amp;&amp;amp; sprite-&amp;gt;initWithFile(filename, rect))
    {
        sprite-&amp;gt;autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}

FilterSprite* FilterSprite::createWithTexture(Texture2D *pTexture)
{
    FilterSprite *sprite = new (std::nothrow) FilterSprite();
    Rect rect = Rect::ZERO;
    rect.size = pTexture-&amp;gt;getContentSize();
    if (sprite &amp;amp;&amp;amp; sprite-&amp;gt;initWithTexture(pTexture,rect))
    {
        sprite-&amp;gt;autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}

FilterSprite* FilterSprite::createWithTexture(Texture2D *texture, const Rect&amp;amp; rect, bool rotated)
{
    FilterSprite *sprite = new (std::nothrow) FilterSprite();
    if (sprite &amp;amp;&amp;amp; sprite-&amp;gt;initWithTexture(texture, rect))
    {
        sprite-&amp;gt;autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}

FilterSprite* FilterSprite::createWithSpriteFrame(SpriteFrame *spriteFrame)
{
    FilterSprite *sprite = new (std::nothrow) FilterSprite();
    if (sprite &amp;amp;&amp;amp; spriteFrame &amp;amp;&amp;amp; sprite-&amp;gt;initWithSpriteFrame(spriteFrame))
    {
        sprite-&amp;gt;autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}

FilterSprite* FilterSprite::createWithSpriteFrameName(const std::string&amp;amp; spriteFrameName)
{
    SpriteFrame *frame = SpriteFrameCache::getInstance()-&amp;gt;getSpriteFrameByName(spriteFrameName);

#if COCOS2D_DEBUG &amp;gt; 0
    char msg[256] = {0};
    sprintf(msg, &amp;quot;Invalid spriteFrameName: %s&amp;quot;, spriteFrameName.c_str());
    CCASSERT(frame != nullptr, msg);
#endif

    return createWithSpriteFrame(frame);
}

bool FilterSprite::initWithTexture(Texture2D* pTexture, const Rect&amp;amp; tRect){
    do{
        CC_BREAK_IF(!Sprite::initWithTexture(pTexture, tRect));

        GLchar* pszFragSource =
            &amp;quot;#ifdef GL_ES \n \
            precision mediump float; \n \
            #endif \n \
            uniform sampler2D u_texture; \n \
            varying vec2 v_texCoord; \n \
            varying vec4 v_fragmentColor; \n \
            uniform mat4 fiterMat; \n \
            void main(void) \n \
            { \n \
            vec4 value = v_fragmentColor*texture2D(u_texture, v_texCoord); \n \
            gl_FragColor = fiterMat*value; \n \
            }&amp;quot;;

         auto glprogram = GLProgram::createWithByteArrays(ccPositionTextureColor_vert, pszFragSource);
         auto glprogramstate = GLProgramState::getOrCreateWithGLProgram(glprogram);
         setGLProgramState(glprogramstate);

         CHECK_GL_ERROR_DEBUG();

         return true;
    } while (0);
    return false;
}

void  FilterSprite::setFilterMat(cocos2d::Mat4 matrixArray)
{
    m_uSpriteFilter=matrixArray;
}

void FilterSprite::draw(Renderer *renderer, const Mat4 &amp;amp;transform, uint32_t flags)
{
    _customCommand.init(_globalZOrder);
    _customCommand.func = CC_CALLBACK_0(FilterSprite::onDraw, this, transform, flags);
    renderer-&amp;gt;addCommand(&amp;amp;_customCommand);
}

void FilterSprite::onDraw(const Mat4 &amp;amp;transform, uint32_t flags)
{
     auto glProgramState = getGLProgramState();
     glProgramState-&amp;gt;setUniformMat4(&amp;quot;fiterMat&amp;quot;,m_uSpriteFilter);
     glProgramState-&amp;gt;apply(transform);

    GL::blendFunc( _blendFunc.src, _blendFunc.dst );

    GL::bindTexture2D( _texture-&amp;gt;getName() );
    GL::enableVertexAttribs( GL::VERTEX_ATTRIB_FLAG_POS_COLOR_TEX );

#define kQuadSize sizeof(_quad.bl)
    size_t offset = (size_t)&amp;amp;_quad;

    // vertex
    int diff = offsetof( V3F_C4B_T2F, vertices);
    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, kQuadSize, (void*) (offset + diff));

    // texCoods
    diff = offsetof( V3F_C4B_T2F, texCoords);
    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_TEX_COORD, 2, GL_FLOAT, GL_FALSE, kQuadSize, (void*)(offset + diff));

    // color
    diff = offsetof( V3F_C4B_T2F, colors);
    glVertexAttribPointer(GLProgram::VERTEX_ATTRIB_COLOR, 4, GL_UNSIGNED_BYTE, GL_TRUE, kQuadSize, (void*)(offset + diff));

    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

    CHECK_GL_ERROR_DEBUG();
    CC_INCREMENT_GL_DRAWN_BATCHES_AND_VERTICES(1,4);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content>
   </entry>
   
   <entry>
     <title>Violet 主题更新</title>
     <link href="http://liaoyanxuan.github.io/2014/09/13/violet-update.html"/>
     <updated>2014-09-13T00:00:00+08:00</updated>
     <id>http://liaoyanxuan.github.io/2014/09/13/violet-update</id>
     <content type="html">&lt;h3 id=&quot;本次更新内容：&quot;&gt;本次更新内容：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;升级 Jekyll 版本到 2.4.0，你可以自定义更多的细节，例如新增分类、书签、数据源等，非常棒！详见【&lt;a href=&quot;http://jekyllrb.com/news/&quot;&gt;news&lt;/a&gt;】。或者很多人都是最新版本了:D&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Violet 增加响应式布局 -- 相信很多人期待。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;其他&quot;&gt;其他&lt;/h3&gt;

&lt;p&gt;在修改之前，为老的版本打了个 Tag，如果你觉得不适应新的 Jekyll 版本，可以回退到 Tag 2.0 。&lt;/p&gt;
</content>
   </entry>
   
 
</feed>

